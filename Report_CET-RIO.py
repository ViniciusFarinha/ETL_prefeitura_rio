# -*- coding: utf-8 -*-
"""Case_ Prefeitura.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/167r-GftiYhWCtxEKyeLamK4EmXhBvdfj

# Pipeline   
    
                                  ┌─────────────────┐
                                  │ Obter Dados de  │
                                  │ Ocorrências     │
                                  │ Abertas         │
                                  └─────────────────┘
                                           │
                                           ▼
                                  ┌─────────────────┐
                                  │ Obtenção de     │
                                  │ todos os Pop's  │
                                  └─────────────────┘
                                           │
                                           ▼
                                  ┌─────────────────┐
                                  │ Utilizar Pop's  │
                                  │ para filtrar    │
                                  │ CET-RIO nas     │
                                  │ ocorrências     │
                                  │ abertas         │
                                  └─────────────────┘
                                           │
                                           ▼
                                  ┌─────────────────┐
                                  │ Dataframe Final │
                                  └─────────────────┘
                                           │
                                           ▼
                                  ┌─────────────────┐
                                  │   Criação do    │
                                  │      Loop       │
                                  └─────────────────┘
                                           │
                                           ▼
                                  ┌─────────────────┐
                                  │     Entrega     │
                                  └─────────────────┘

# Projeto
"""

# Import de bibliotecas
import requests
import pandas as pd
import logging
import time
from time import sleep
from datetime import datetime
import json
import pytz
import csv

# Configurar o logger
logging.basicConfig(filename='error.log', level=logging.ERROR)

# Buscando todas as ocorrências abertas


def ocorrencias_abertas():
    try:
        # Fazendo requisição no site
        req = requests.get('https://api.dados.rio/v2/adm_cor_comando/ocorrencias_abertas/')

        # Condições
        if req.status_code == 200:
            # Lendo JSON
            json_df1 = req.json()['eventos']
            # Transformando JSON em Dataframe
            df1 = pd.DataFrame(json_df1)
            # Drop de colunas no dataframe
            df1 = df1.drop(axis=1, columns=['anexos', 'bairro', 'longitude', 'descricao', 'latitude', 'prazo', 'gravidade', 'informe_id'])
            # Display do Dataframe
            return df1
        else:
            raise Exception('Erro ao acessar a API de ocorrencias abertas')
    except Exception as e:
        logging.error(f'Erro em ocorrencias_abertas: {str(e)}')
        print('Erro ao obter ocorrencias abertas.')
        return None

# Buscando Pop's
def pops():
    try:
        # Fazendo requisição no site
        request = requests.get('https://api.dados.rio/v2/adm_cor_comando/pops/')

        # Condições
        if request.status_code == 200:
            # Lendo JSON
            json_df2 = request.json()['objeto']

            # Lista para armazenar os valores de 'id'
            id_list = []

            for item in json_df2:
                id_list.append(item['id'])
            id_list.sort()
            id_list.remove(0)

            return id_list
        else:
            raise Exception('Erro ao acessar a API de pops')
    except Exception as e:
        logging.error(f'Erro em pops: {str(e)}')
        print('Erro ao obter pops.')
        return None

# filtrando tabela de ocorrencias a partir dos  Pop's
def pop_filter(id_list):
    try:
        # Site url
        base_url = 'https://api.dados.rio/v2/adm_cor_comando/procedimento_operacional_padrao_orgaos_responsaveis/?popId='

        # Lista para dados
        data = []

        # Buscando todos os procedimentos operacionais a partir de cada pop_id da lista
        for id_value in id_list:
            url = base_url + str(id_value)
            request = requests.get(url)
            response = request.json()
            data.append(response)

        # Criando dataframe a partir dos dados
        df = pd.DataFrame(data)
        atividades = df['atividades'].to_list()
        df_atividades = pd.DataFrame(columns=['sigla', 'orgao', 'acao'])

        for i in range(len(atividades)):
            item = atividades[i][0]  # Acessar o primeiro elemento do dicionário na lista
            df_atividades.loc[i] = [item['sigla'], item['orgao'], item['acao']]

        df_POP_ID = pd.concat([df, df_atividades], axis=1)
        df_POP_ID.drop(columns=['atividades', 'orgao', 'acao'], inplace=True)
        df_POP_ID['POP_ID'] = range(1, len(df_POP_ID) + 1)
        # Remover as linhas em que a sigla não seja 'CET-RIO'
        df_POP_ID = df_POP_ID[df_POP_ID['sigla'] == 'CET-RIO']

        # Redefinir o índice do DataFrame
        df_POP_ID = df_POP_ID.reset_index(drop=True)

        return df_POP_ID
    except Exception as e:
        logging.error(f'Erro em pop_filter: {str(e)}')
        print('Erro ao filtrar pops.')
        return None

# Tratamento do Dataframe final
def final(df1, df_POP_ID):
    try:
        # Filtrar as linhas com o mesmo 'pop_id' em ambos os dataframes
        df_merged = df1[df1['pop_id'].isin(df_POP_ID['POP_ID'])]
        df_final = df_merged.drop(columns=['pop_id', 'id', 'tipo', 'inicio'])
        df_final['data_verificacao'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        df_final['quantidade_ocorrencia'] = df_final['status'].map(df_final['status'].value_counts())
        return df_final
    except Exception as e:
        logging.error(f'Erro em final: {str(e)}')
        print('Erro ao processar o dataframe final.')
        return None


def compare_and_export(df_final):
    try:
        # Comparando linhas e adicionando apenas as linhas novas
        novas_linhas = pd.DataFrame([dados for dados in df_final if dados not in df_final.to_dict()])

        df_final = pd.concat([df_final, novas_linhas])
        display(df_final)
    except Exception as e:
        logging.error(f'Erro em compare_and_export: {str(e)}')
        print('Erro ao comparar e exportar o dataframe final.')

# funçãO Completa
def obter_dados():
    df1 = ocorrencias_abertas()
    id_list = pops()
    df_POP_ID = pop_filter(id_list)
    df_final = final(df1, df_POP_ID)
    compare_and_export(df_final)
    with open('tabela.csv', mode='w', newline='') as file:
       writer = csv.writer(file)
       writer.writerows(df_final)

# Criando Loop final
def loop():
    tempo_inicial = time.time()  # Tempo de início do loop
    tempo_limite = 3600  # 1 hora (em segundos)
    # Define o fuso horário de Brasília
    tz = pytz.timezone('America/Sao_Paulo')
    hora_pesquisa = datetime.now(tz).strftime('%H:%M:%S')  # data e hota da pesquisa

    while True:
        print(f'----Busca feita às {hora_pesquisa} ----')
        print('')
        obter_dados()
        print('')
        print(f'----Próxima Busca feita será feita em 20 minutos ----')

        # Verificar se o tempo decorrido ultrapassou o limite de 1 hora
        if time.time() - tempo_inicial >= tempo_limite:
            break

        time.sleep(1200)  # Aguardar 20 minutos (20 * 60 segundos)

loop()